<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Definition of Schema.org (unofficial)</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" crossorigin="anonymous">
    <style>
        h1 { font-size: 1.6rem; }
        section {
            margin-bottom: 2em;
        }
        h2 { font-size: 1.4rem; }
        dl {
            display: flex;
            margin-bottom: 0;
        }
        dt {
            width: 12em;
            white-space: nowrap;
        }
        dd { flex: 1; }
        ul {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body class="container">
    <h1>
        Vocabulary Definition of
        <a href="https://schema.org/docs/developers.html#defs">Schema.org</a>
    </h1>
    <main></main>
    <footer></footer>
    <script type="module">
import kongUtil from 'https://cdn.jsdelivr.net/npm/kong-util/mod/all.mjs';
kongUtil.use();
// const schema = await fetchJSON('https://schema.org/version/latest/schemaorg-current-https.jsonld');
const schema = await fetchJSON('schemaorg-current-https.jsonld')
    .catch(() => fetchJSON('https://schema.org/version/latest/schemaorg-current-https.jsonld'))
;


const properties = [
    '@id', '@type',
    'dcterms:source',
    'owl:equivalentClass', 'owl:equivalentProperty',
    'rdfs:label', 'rdfs:comment', 'rdfs:subClassOf', 'rdfs:subPropertyOf',
    'schema:domainIncludes', 'schema:inverseOf', 'schema:isPartOf',
    'schema:rangeIncludes', 'schema:sameAs', 'schema:source', 'schema:supersededBy',
    'skos:closeMatch', 'skos:exactMatch'
];

const c = $('main'); // container
const d = schema['@graph']; // data
d.forEach(g => {
    const id = g['@id'].substring(7);
    const typeList = (Array.isArray(g['@type']) ? g['@type'] : [g['@type']])
        .map(type => {
            if(type.startsWith('schema:'))
                return {category: 'schema', bg: 'primary', name: type.substring(7)};
            if(type === 'rdf:Property')
                return {category: 'rdf', bg: 'info', name: 'Property'};
            if(type === 'rdfs:Class')
                return {category: 'rdfs', bg: 'warning', name: 'Class'};
            console.error('unknown type', type);
        });
    ;

    const es = [ // elements
        {h2: {
            id,
            title: '@id',
            text: id
        }}
    ];
    if(g.hasOwnProperty('schema:supersededBy')) {
        es.push(
            {dl: {$: [
                {dt: {$: [
                    {span: {
                        class: 'badge bg-danger',
                        text: 'schema:supersededBy'
                    }}
                ]}},
                {dd: g['schema:supersededBy']['@id']}
            ]}}
        );
    }

    es.push(
        {dl: {$: [
            {dt: '@type'},
            {dd: {$: [
                {ul: {
                    class: 'list-inline',
                    $: typeList.map(type => (
                        {li: {$: [
                            type.category + ':',
                            {span: {
                                class: `badge text-bg-${type.bg}`,
                                text: type.name
                            }}
                        ]}}
                    ))
                }}
            ]}}
        ]}},
        {dl: {$: [
            {dt: 'rdfs:comment'},
            {dd: (typeof g['rdfs:comment'] === 'string')
                ? g['rdfs:comment']
                : g['rdfs:comment']['@value']
            }
        ]}}
    );

    [
        'dcterms:source',
        'owl:equivalentClass', 'owl:equivalentProperty',
        'rdfs:subClassOf', 'rdfs:subPropertyOf',
        'schema:domainIncludes', 'schema:inverseOf', 'schema:isPartOf',
        'schema:rangeIncludes', 'schema:sameAs', 'schema:source',
        'skos:closeMatch', 'skos:exactMatch'
    ].forEach(prop => {
        if(!g.hasOwnProperty(prop)) return;
        if(!Array.isArray(g[prop])) g[prop] = [g[prop]];
        es.push(
            {dl: {$: [
                {dt: prop},
                {dd: {$: [
                    {ul: {
                        class: 'list-unstyled',
                        $: g[prop].map(obj => (
                            {li: obj['@id']}
                        ))
                    }}
                ]}}
            ]}}
        );
    });

    for(let prop in g)
        if(!properties.includes(prop)) console.log(prop);

    c.append(createElement({section: {$: es}}));
});

    </script>
</body>
</html>