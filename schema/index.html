<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Definition of Schema.org (unofficial)</title>
    <base target="_blank">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20,400,0,0" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" crossorigin="anonymous"></script>
    <style>
        h1 { font-size: 1.6rem; }
        section {
            margin-bottom: 2em;
        }
        h2 { font-size: 1.4rem; }
        dl {
            display: flex;
            margin-bottom: 0;
        }
        dt {
            min-width: 12em;
            white-space: nowrap;
            flex: 0;
        }
        dd { flex: 1; }
        ul {
            margin: 0;
            padding: 0;
        }
        [class^=link] { cursor: pointer; }

        section > dl:not([class="rdfs:comment"]) > dd {
            font-family: monospace;
        }
        .property-category {
            font-weight: normal;
            color: #888;
            font-size: smaller;
        }
    </style>
</head>
<body class="container">
    <header class="mb-3 pb-2 border-bottom">
        <h1>
            Vocabulary Definition of
            <a href="https://schema.org/docs/developers.html#defs">Schema.org</a>
        </h1>
        <dl>
            <dt>search</dt>
            <dd>
                <input type="text"
                    class="form-control"
                    placeholder="search vocabulary (case-insensitive)"
                >
            </dd>
        </dl>
        <dl>
            <dt>vocabulary to show</dt>
            <dd class="row">
                <label class="col-6">
                    <input type="checkbox"
                        class="form-check-input me-1"
                        checked
                        disabled
                    >current
                </label>
                <label class="col-6">
                    <input type="checkbox"
                        class="form-check-input me-1"
                        checked
                    >superseded
                </label>
            </dd>
        </dl>
        <dl>
            <dt>properties to show</dt>
            <dd id="propertiesContainer" class="row"></dd>
        </dl>
    </header>
    <main></main>
    <footer></footer>
    <script type="module">
import kongUtil from 'https://cdn.jsdelivr.net/npm/kong-util/mod/all.mjs';
kongUtil.use();

const schema = await fetchJSON('schemaorg-current-https.jsonld')
    .catch(() => fetchJSON('https://schema.org/version/latest/schemaorg-current-https.jsonld'))
;

const properties = [
    '@id', '@type',
    'dcterms:source',
    'owl:equivalentClass', 'owl:equivalentProperty',
    'rdfs:label', 'rdfs:comment', 'rdfs:subClassOf', 'rdfs:subPropertyOf',
    'schema:domainIncludes', 'schema:inverseOf', 'schema:isPartOf',
    'schema:rangeIncludes', 'schema:sameAs', 'schema:source', 'schema:supersededBy',
    'skos:closeMatch', 'skos:exactMatch'
];

properties.forEach(prop => {
    $('#propertiesContainer').append(createElement(
        {label: {
            class: 'col-6',
            $: [
                {input: {
                    type: 'checkbox',
                    class: 'form-check-input me-1',
                    checked: ''
                }},
                prop
            ]
        }}
    ));
});

const data = schema['@graph'];
data.forEach(vocab => {
    const id = vocab.id = vocab['@id'].substring(7);
    const typeList = (Array.isArray(vocab['@type']) ? vocab['@type'] : [vocab['@type']])
        .map(type => {
            if(type.startsWith('schema:'))
                return {category: 'schema', bg: 'primary', name: type.substring(7)};
            if(type === 'rdf:Property')
                return {category: 'rdf', bg: 'info', name: 'Property'};
            if(type === 'rdfs:Class')
                return {category: 'rdfs', bg: 'warning', name: 'Class'};
            console.error('unknown type', type);
        });
    ;

    const es = [ // elements
        {h2: {
            class: '@id',
            $: [
                id,
                {a: {
                    class: 'material-symbols-outlined text-decoration-none',
                    href: 'https://schema.org/' + id,
                    text: 'open_in_new'
                }}
            ]
        }}
    ];

    if(vocab.hasOwnProperty('schema:supersededBy')) {
        es.push(
            {dl: {
                class: 'schema:supersededBy',
                $: [
                    {dt: {$: [
                        {span: {
                            class: 'property-category',
                            text: 'schema:'
                        }},
                        {span: {
                            class: 'property-namebadge badge bg-danger',
                            text: 'supersededBy'
                        }}
                    ]}},
                    {dd: {$: [
                        createLinkFromName(vocab['schema:supersededBy']['@id'])
                    ]}}
                ]
            }}
        );
    }

    es.push(
        {dl: {
            class: '@type',
            $: [
                {dt: {$: [
                    {span: {
                        class: 'property-category',
                        text: '@'
                    }},
                    {span: {
                        class: 'property-name',
                        text: 'type'
                    }}
                ]}},
                {dd: {$: [
                    {ul: {
                        class: 'list-inline',
                        $: typeList.map(type => (
                            {li: {$: [
                                type.category + ':',
                                {span: {
                                    class: `badge text-bg-${type.bg}`,
                                    text: type.name
                                }}
                            ]}}
                        ))
                    }}
                ]}}
            ]
        }},
        {dl: {
            class: 'rdfs:comment',
            $: [
                {dt: departPropertyName('rdfs:comment')},
                {dd: {$: parseComment(vocab)}}
            ]
        }}
    );

    [
        'dcterms:source',
        'owl:equivalentClass', 'owl:equivalentProperty',
        'rdfs:subClassOf', 'rdfs:subPropertyOf',
        'schema:domainIncludes', 'schema:inverseOf', 'schema:isPartOf',
        'schema:rangeIncludes', 'schema:sameAs', 'schema:source',
        'skos:closeMatch', 'skos:exactMatch'
    ].forEach(prop => {
        if(!vocab.hasOwnProperty(prop)) return;
        if(!Array.isArray(vocab[prop])) vocab[prop] = [vocab[prop]];
        es.push(
            {dl: {
                class: prop,
                $: [
                    {dt: departPropertyName(prop)},
                    {dd: {$: [
                        {ul: {
                            class: 'list-unstyled',
                            $: vocab[prop].map(obj => (
                                {li: {$: [
                                    createLinkFromName(obj['@id'])
                                ]}}
                            ))
                        }}
                    ]}}
                ]
            }}
        );
    });

    for(let prop in vocab)
        if(!properties.includes(prop) && prop !== 'id') console.log(prop);

    requestIdleCallback(() => {
        const section = createElement(
            {section: {
                id,
                class: vocab.hasOwnProperty('schema:supersededBy') ? 'superseded' : '',
                $: es
            }}
        );
        $$('.vocabulary', section).forEach(span => {
            const name = span.textContent;
            span.replaceWith(createElement(
                {span : {
                    class: 'link-primary',
                    text: name,
                    onclick: () => scrollToId(name)
                }}
            ))
        });
        $('main').append(section);
    });
});


/**
 * 先建好「不要顯示這個類別名稱」的 <style> 們，需要時再套用。
 */
const styles = properties.reduce(
    (acc, property) => Object.assign(acc, {
        [property]: createElement(
            {style: `[class="${property}"] { display: none; }`}
        )
    }
), {
    superseded: createElement({style: '.superseded { display: none; }'})
});
$$('[type=checkbox]').forEach(checkbox => {
    listen(checkbox, 'click', () => {
        const prop = checkbox.nextSibling.textContent.trim();
        if(checkbox.checked) styles[prop].remove();
        else document.head.append(styles[prop]);
    });
});


listen($('[type=text]'), 'input', event => {
    /**
     * 拆解搜尋框的字串
     * 例如 'aa bb "cc dd ee" gg"hh'
     * 即應被拆解成 ['aa', 'bb', 'cc dd ee', 'gg"hh']
     */
    const needles = event.target.value.trim()
        .split(/\s+/).filter(x => x)
        .map(str => str.toLowerCase())
    ;
    let pos;
    while((pos = needles.findIndex(n => n.startsWith('"'))) !== -1) {
        const last = needles.findIndex((n, i) => {
            if(!n.endsWith('"') || i < pos) return false;
            if(i === pos && n.length === 1) return false; // '"'
            return true;
        });
        if(last === -1) break;
        const combinedNeedle = needles.slice(pos, last + 1).join(' ').slice(1, -1); // 移掉頭尾的雙引號
        if(combinedNeedle.length) needles.splice(pos, last - pos + 1, combinedNeedle);
        else needles.splice(pos, 1);
    }
    // console.debug(needles);

    // 資料建完前，某些元件還不存在，會觸發錯誤，故存取其他元件的動作要包在 requestIdleCallback 裡。
    requestIdleCallback(() => {
        data.forEach(voc => {
            $(`[id="${voc.id}"]`).style.display = searchInProperties(needles, voc) ? '' : 'none';
        });
    });
});


/**
 * @param {string[]} needles
 * @param {string|Array|Object} target
 * @returns {boolean}
 */
function searchInProperties(needles, target) {
    if(!needles.length) return true;
    if(typeof target === 'string')
        return needles.some(needle => target.toLowerCase().includes(needle));
    if(Array.isArray(target))
        return target.some(elem => searchInProperties(needles, elem));
    for(let prop in target) {
        if(searchInProperties(needles, target[prop])) return true;
    }
    return false;
}


function departPropertyName(str) {
    const [category, name] = str.split(':');
    return {$: [
        {span: {
            class: 'property-category',
            text: category + ':'
        }},
        {span: {
            class: 'property-name',
            text: name
        }}
    ]};
}

function createLinkFromName(str) {
    const [category, name] = str.split(':');
    switch(category) {
        case 'http':
        case 'https':
            return {a: {
                href: str,
                text: str
            }};
        case 'schema':
            return {span : {
                class: 'link-primary',
                text: str,
                onclick: () => scrollToId(name)
            }};
        case 'foaf':
            return {a: {
                href: `http://xmlns.com/foaf/0.1/#term_${name}`,
                text: str
            }};
        case 'dcmitype':
            return {a: {
                href: `https://www.dublincore.org/specifications/dublin-core/dcmi-terms/dcmitype/${name}/`,
                text: str
            }};
        case 'dcterms':
            return {a: {
                href: `https://www.dublincore.org/specifications/dublin-core/dcmi-terms/terms/${name}/`,
                text: str
            }};
        case 'dcat':
            return {a: {
                href: `https://www.w3.org/TR/vocab-dcat-3/#Class:${name}`,
                text: str
            }};
        case 'rdf':
        case 'rdfs':
            return {a: {
                href: 'https://www.w3.org/TR/2014/REC-rdf-schema-20140225/#ch_' + name.toLowerCase(),
                text: str
            }};
        case 'void':
            return {a: {
                href: 'https://www.w3.org/TR/void/',
                text: str
            }};
        default:
            console.log(str);
            return str;
    }
}

/**
 * @returns {Element[]}
 */
function parseComment(vocab) {
    let md = (typeof vocab['rdfs:comment'] === 'string')
        ? vocab['rdfs:comment']
        : vocab['rdfs:comment']['@value']
    ;
    md = md.replace(/\\n/g, '\n');

    let html = '<div>' + marked.parse(md) + '</div>';
    html = html.replace(/\[\[(\w+)\]\]/g, '<span class="vocabulary">$1</span>');
    return [...parseHTML(html).childNodes];
}

function scrollToId(id) {
    $('[type=text]').value = '';
    $('[type=text]').dispatchEvent(new Event('input'));
    requestIdleCallback(() => {
        window.scroll(0, $(`[id="${id}"]`).offsetTop);
    });
}

// requestIdleCallback(() => console.debug('loaded'));
    </script>
</body>
</html>
